name: üöÄ Deploy GazaAidSync to VPS

on:
  push:
    branches:
      - main
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    # // if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    # Note: Uncomment the above line to enable deploys on direct pushes to main branch as well as merged PRs.

    steps:
      # 1Ô∏è‚É£ Checkout the latest code from repository
      - name: Checkout Repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Setup Node.js with built-in npm caching
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      # 3Ô∏è‚É£ Install dependencies (cached by setup-node)
      # Do we really need to install here if we build on server? Yes, to validate code and catch errors early.
      # This step ensures that the code is valid and dependencies are correct before deployment. If there are issues, they are caught early in the CI process.
      # It also allows us to run any pre-deployment scripts or checks if needed in the future.
      # It's a good practice to validate the build locally before deploying to avoid deploying broken code.
      # However, the actual production dependencies will be installed on the server during deployment, and we already handling rollback there in case of failures.
      # We can comment out this step if we want to speed up the workflow and rely solely on server-side build validation.
      # - name: Install dependencies
      #   run: npm ci --legacy-peer-deps

      # 4Ô∏è‚É£ Setup SSH connection
      - name: Setup SSH Connection
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      # 5Ô∏è‚É£  Upload & deploy steps
      # Deploy build with auto backup and rotation
      # Upload source files to a TEMP dir on the VPS (atomic swap/deploy)
      - name: Upload source to VPS (to temp dir)
        env:
            VPS_USER: ${{ secrets.VPS_USER }}
            VPS_HOST: ${{ secrets.VPS_HOST }}
        run: |
            set -euo pipefail  # Exit on any error
            
            echo "üì¶ Starting atomic upload..."
            echo "üîç Validating environment variables..."
            
            # Validate required secrets
            if [ -z "${VPS_USER}" ] || [ -z "${VPS_HOST}" ]; then
              echo "‚ùå ERROR: VPS_USER or VPS_HOST secrets are not set!"
              exit 1
            fi
            
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV  # ‚úÖ Export for next step
            echo "‚è∞ Deployment timestamp: ${TIMESTAMP}"

            TMPDIR="/home/${VPS_USER}/htdocs/www.gaza.family_deploy_${TIMESTAMP}"
            REMOTE_BACKUPS_DIR="/home/${VPS_USER}/backups/www.gaza.family"

            # Test SSH connection first
            echo "üîê Testing SSH connection..."
            if ! ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${VPS_USER}@${VPS_HOST} "echo 'SSH connection successful'"; then
              echo "‚ùå ERROR: Cannot connect to VPS via SSH!"
              exit 1
            fi

            # make tmpdir & backups dir
            echo "üõ†Ô∏è Creating tmp & backup dirs on remote..."
            if ! ssh -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_HOST} "mkdir -p ${TMPDIR} ${REMOTE_BACKUPS_DIR}"; then
              echo "‚ùå ERROR: Failed to create directories on VPS!"
              exit 1
            fi

            # Upload files dynamically from .deployinclude (no hardcoding)
            echo "üöÄ Uploading source files to ${TMPDIR}..."
            
            # Validate .deployinclude exists
            if [ ! -f ".deployinclude" ]; then
              echo "‚ùå ERROR: .deployinclude file not found!"
              echo "üìù Please create a .deployinclude file with the files/directories to deploy"
              exit 1
            fi
            
            echo "üìã Files to deploy (from .deployinclude):"
            cat .deployinclude | grep -v '^#' | grep -v '^$' || echo "‚ö†Ô∏è No files specified in .deployinclude"
            # Perform rsync upload with exclusions and include-from
            if ! rsync -avz --delete \
              -e "ssh -o StrictHostKeyChecking=no" \
              --exclude='.git' \
              --exclude='.github' \
              --exclude='*.log' \
              --exclude='scripts' \
              --exclude='node_modules' \
              --exclude='.next' \
              --exclude='coverage' \
              --exclude='*.test.*' \
              --exclude='*.spec.*' \
              --include-from='.deployinclude' \
              ./ ${VPS_USER}@${VPS_HOST}:${TMPDIR}/; then
              echo "‚ùå ERROR: File upload failed!"
              exit 1
            fi
            
            echo "‚úÖ File upload completed successfully"

      # 6Ô∏è‚É£ Build & activate on VPS with atomic swap, pm2 restart, backup rotation, and rollback on failure
      - name: Build & Activate on VPS (atomic, with rollback & backup rotation)
        env:
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_HOST: ${{ secrets.VPS_HOST }}
          TIMESTAMP: ${{ env.TIMESTAMP }}  # ‚úÖ Reuse same timestamp
        run: |
          set -euo pipefail  # Exit on any error
          
          echo "üîÅ Building & activating new version on VPS..."
          echo "üîç Validating deployment environment..."

          # Validate required environment variables
          if [ -z "${VPS_USER}" ] || [ -z "${VPS_HOST}" ] || [ -z "${TIMESTAMP}" ]; then
            echo "‚ùå ERROR: Missing required environment variables!"
            exit 1
          fi

          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${VPS_USER}@${VPS_HOST} \
            "bash -s -- ${TIMESTAMP}" <<'EOF'
            set -euo pipefail

            # Use timestamp from env
            TIMESTAMP="$1"
            VPS_USER="${USER}"

            TMPDIR="/home/${VPS_USER}/htdocs/www.gaza.family_deploy_${TIMESTAMP}"
            LIVEDIR="/home/${VPS_USER}/htdocs/www.gaza.family"
            BACKUP_DIR="/home/${VPS_USER}/backups/www.gaza.family"

            echo "üìÇ Preparing to activate build at ${TMPDIR}"
            echo "üîç Validating deployment environment on VPS..."

            # Ensure backup dir exists
            if ! mkdir -p "${BACKUP_DIR}"; then
              echo "‚ùå ERROR: Failed to create backup directory ${BACKUP_DIR}"
              exit 1
            fi

            # Clean up old temporary deploy directories (older than 1 day)
            echo "üßπ Cleaning old temporary deploy directories..."
            find /home/${VPS_USER}/htdocs -maxdepth 1 -type d -name 'www.gaza.family_deploy_*' -mtime +1 -exec rm -rf {} + || true

            if [ ! -d "${TMPDIR}" ]; then
              echo "‚ùå ERROR: Temp directory not found (${TMPDIR})"
              echo "üîç Available directories in /home/${VPS_USER}/htdocs/:"
              ls -la /home/${VPS_USER}/htdocs/ || echo "Directory listing failed"
              exit 1
            fi

            # Check if temp directory has expected files
            if [ ! -f "${TMPDIR}/package.json" ]; then
              echo "‚ùå ERROR: package.json not found in temp directory!"
              echo "üîç Contents of temp directory:"
              ls -la "${TMPDIR}" || echo "Directory listing failed"
              exit 1
            fi

            # Preserve existing .env and node_modules
            if [ -f "${LIVEDIR}/.env" ]; then
              echo "üîê Preserving existing .env"
              cp "${LIVEDIR}/.env" "${TMPDIR}/.env"
            fi

            # üß† Smart node_modules preservation: copy from live dir if no deps changed
            if [ -f "$LIVEDIR/package-lock.json" ] && cmp -s package-lock.json "$LIVEDIR/package-lock.json"; then
              echo "‚úÖ No dependency changes detected"
              if [ -d "$LIVEDIR/node_modules" ]; then
                echo "üì¶ Preserving existing node_modules from live directory..."
                # Used rsync for more efficient copying with progress
                if rsync -a --info=progress2 "$LIVEDIR/node_modules/" "${TMPDIR}/node_modules/"; then
                  # This wil copy the *contents* of node_modules, not the folder itself, into the temporary directory.
                  # If the destination folder (${TMPDIR}/node_modules/) doesn't exist yet,
                  # rsync will create it first, preventing all the contents from being copied directly
                  # into the ${TMPDIR} root, which is an unwanted behavior.
                  # Otherwise, we have to copy the entire node_modules folder itself 
                  # without a trailing slash to ensure that we don't end up copying 
                  # all the heavy content of the node_modules folder inside the TMPDIR root, which we don't want
                  echo "‚úÖ node_modules preserved successfully"
                else
                  echo "‚ö†Ô∏è Failed to preserve node_modules, will install fresh"
                  rm -rf "${TMPDIR}/node_modules" 2>/dev/null || true
                fi
              else
                echo "‚ö†Ô∏è No existing node_modules found in live directory"
              fi
            else
              echo "üì¶ Dependency changes detected, will install fresh node_modules"
              # Clean any existing node_modules in tmpdir
              rm -rf "${TMPDIR}/node_modules" 2>/dev/null || true
            fi

            # install production dependencies inside tmpdir
            echo "üì¶ Installing production dependencies in tmp and building on VPS..."
            cd "${TMPDIR}"

            # Load Node version via nvm (pm2 uses nvm)
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

            # Check Node.js version
            echo "üîç Node.js version: $(node --version)"
            echo "üîç npm version: $(npm --version)"

            # üß† Smart install: skip if node_modules exists and is valid
            if [ -d "node_modules" ]; then
              echo "‚úÖ node_modules exists, validating installation..."
              
              # Quick validation: check if key packages exist
              if [ -d "node_modules/.prisma" ] && [ -d "node_modules/next" ] && [ -d "node_modules/react" ]; then
                echo "‚úÖ node_modules appears valid, skipping npm ci"
              else
                echo "‚ö†Ô∏è node_modules appears incomplete, installing dependencies..."
                rm -rf node_modules
                if ! npm ci --legacy-peer-deps; then
                  echo "‚ùå ERROR: npm install failed!"
                  echo "üîç Checking npm cache and retrying..."
                  npm cache clean --force
                  if ! npm ci --legacy-peer-deps; then
                    echo "‚ùå ERROR: npm install failed after cache clean!"
                    exit 1
                  fi
                fi
              fi
            else
              echo "üì¶ Installing dependencies..."
              if ! npm ci --legacy-peer-deps; then
                echo "‚ùå ERROR: npm install failed!"
                echo "üîç Checking npm cache and retrying..."
                npm cache clean --force
                if ! npm ci --legacy-peer-deps; then
                  echo "‚ùå ERROR: npm install failed after cache clean!"
                  exit 1
                fi
              fi
            fi

            echo "‚öôÔ∏è Generating Prisma client..."
            # npx prisma generate || echo "‚ö†Ô∏è Prisma generate failed (ignored)" # We'll comment this command out since it'll be run during build command next

            echo "üèóÔ∏è Building Next.js app..."
            if ! npm run build; then
              echo "‚ùå ERROR: Build failed!"
              echo "üîç Build logs:"
              echo "Checking if there are any build artifacts..."
              ls -la .next/ 2>/dev/null || echo "No .next directory found"
              exit 1
            fi

            # sanity check: ensure build files exist
            if [ ! -d ".next" ]; then
              echo "‚ùå Build artifact .next missing in tmpdir. Aborting."
              echo "üîç Contents of build directory:"
              ls -la "${TMPDIR}" || echo "Directory listing failed"
              exit 1
            fi

            echo "‚úÖ Build completed successfully"

            # Backup current live version
            if [ -d "${LIVEDIR}" ]; then
              echo "üóÑÔ∏è Backing up current live site..."
              mkdir -p "${BACKUP_DIR}"
              cp -r "${LIVEDIR}" "${BACKUP_DIR}/backup_${TIMESTAMP}"
            fi

            # atomic swap: move tmpdir into place
            echo "üîÅ Swapping ${TMPDIR} ‚Üí ${LIVEDIR}"
            # remove live dir and move new into place (we already made a backup)
            rm -rf "${LIVEDIR}"
            mv "${TMPDIR}" "${LIVEDIR}"

            # ensure correct owner permissions (in case)
            chown -R $(whoami):$(whoami) "${LIVEDIR}"

            # reload pm2 (zero-downtime)
            echo "‚ôªÔ∏è Restarting PM2 process..."
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

            # Check if PM2 is installed and working
            if ! command -v pm2 >/dev/null 2>&1; then
              echo "‚ùå ERROR: PM2 is not installed or not in PATH!"
              exit 1
            fi

            echo "üîç Current PM2 processes:"
            pm2 list || echo "PM2 list command failed"

            if pm2 reload gaza-family --update-env; then
              echo "‚úÖ PM2 reloaded successfully."
              sleep 5  # Give it time to start
              
              # Verify the process is actually running
              if pm2 list | grep -q "gaza-family.*online"; then
                echo "‚úÖ PM2 process is confirmed online"
              else
                echo "‚ö†Ô∏è PM2 process is not online after reload, checking logs..."
                pm2 logs gaza-family --lines 20 || echo "Could not get PM2 logs"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è PM2 reload failed, attempting fresh start..."
              
              # Stop existing process first
              pm2 stop gaza-family || echo "No existing process to stop"
              pm2 delete gaza-family || echo "No existing process to delete"
              
              # Try to start fresh
              if pm2 start npm --name "gaza-family" -- run start; then
                echo "‚úÖ PM2 started successfully"
                sleep 5
                
                if pm2 list | grep -q "gaza-family.*online"; then
                  echo "‚úÖ PM2 process is confirmed online"
                else
                  echo "‚ùå PM2 process failed to start properly"
                  pm2 logs gaza-family --lines 20 || echo "Could not get PM2 logs"
                  exit 1
                fi
              else
                echo "‚ùå PM2 failed to start: rolling back to previous backup..."
                LATEST_BACKUP=$(ls -dt ${BACKUP_DIR}/backup_* 2>/dev/null | head -n 1 || true)
                if [ -n "$LATEST_BACKUP" ] && [ -d "$LATEST_BACKUP" ]; then
                  echo "üîÑ Rolling back to backup: ${LATEST_BACKUP}"
                  rm -rf "${LIVEDIR}"
                  cp -r "$LATEST_BACKUP" "${LIVEDIR}"
                  
                  if pm2 reload gaza-family --update-env || pm2 start npm --name "gaza-family" -- run start; then
                    echo "‚úÖ Rollback successful"
                  else
                    echo "‚ùå Rollback failed - manual intervention required!"
                    exit 1
                  fi
                else
                  echo "‚ùå No backup found ‚Äî manual fix needed!"
                  exit 1
                fi
              fi
            fi

            # Rotate backups (keep 3 latest)
            echo "üßπ Cleaning old backups..."
            cd "${BACKUP_DIR}"
            ls -dt backup_* 2>/dev/null | tail -n +4 | xargs -r rm -rf || true

            echo "‚úÖ Deployment completed successfully."
          EOF

      # # üîç Health check after deployment
      # - name: Health Check
      #   env:
      #     VPS_USER: ${{ secrets.VPS_USER }}
      #     VPS_HOST: ${{ secrets.VPS_HOST }}
      #   run: |
      #     echo "üè• Performing health check..."
          
      #     # Wait a moment for PM2 to fully start
      #     sleep 10
          
      #     # Check if PM2 process is running
      #     if ssh -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_HOST} "pm2 list | grep -q 'gaza-family.*online'"; then
      #       echo "‚úÖ PM2 process is running"
      #     else
      #       echo "‚ùå PM2 process is not running - deployment may have failed"
      #       exit 1
      #     fi
          
      #     # Try to make a request to the app (if URL is available)
      #     # Note: Add your app URL to secrets if you want to test HTTP response
      #     # if [ -n "${APP_URL:-}" ]; then
      #     #   if curl -f -s "${APP_URL}" > /dev/null; then
      #     #     echo "‚úÖ App is responding to HTTP requests"
      #     #   else
      #     #     echo "‚ö†Ô∏è App is not responding to HTTP requests"
      #     #   fi
      #     # fi
          
      #     echo "‚úÖ Health check completed successfully"

      # # üì¢ Deployment notification (optional)
      # - name: Deployment Notification
      #   if: always()
      #   run: |
      #     if [ "${{ job.status }}" == "success" ]; then
      #       echo "üéâ Deployment completed successfully!"
      #       # Add webhook notification here if desired
      #       # SLACK_WEBHOOK_URL="${{ secrets.SLACK_WEBHOOK_URL }}"
      #       # if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
      #       #   curl -X POST -H "Content-Type: application/json" \
      #       #     -d '{"text":"‚úÖ GazaAidSync deployed successfully"}' \
      #       #     "${SLACK_WEBHOOK_URL}" || true
      #       # fi
      #     else
      #       echo "‚ùå Deployment failed!"
      #       # Add failure notification here if desired
      #       # SLACK_WEBHOOK_URL="${{ secrets.SLACK_WEBHOOK_URL }}"
      #       # if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
      #       #   curl -X POST -H "Content-Type: application/json" \
      #       #     -d '{"text":"‚ùå GazaAidSync deployment failed"}' \
      #       #     "${SLACK_WEBHOOK_URL}" || true
      #       # fi
      #     fi